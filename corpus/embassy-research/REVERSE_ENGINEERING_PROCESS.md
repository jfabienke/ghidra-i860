### Reverse Engineering the NeXTdimension: A Chronicle of Discovery and Emulation

The quest to fully emulate the NeXTdimension graphics board in the Previous emulator began as a deep dive into one of NeXT Computer's most enigmatic hardware innovations. Launched in 1991 as a $3,995 expansion card for the NeXTcube and NeXTstation, the NeXTdimension offloaded graphics processing to an Intel i860 RISC processor running a stripped-down Mach kernel known as "GaCK." This board promised revolutionary Display PostScript (DPS) acceleration at 1120x832 resolution with 32-bit color, but its proprietary firmware and closed architecture had long obscured its inner workings. Our project, documented across a series of evolving Markdown files from the Previous source repository, unfolded over phases of meticulous reverse engineering. What started as a raw examination of ROM dumps evolved into a comprehensive blueprint for emulation, blending static analysis, disassembly, protocol dissection, and verification to bridge 1990s hardware with modern software preservation. This writeup traces the process chronologically, weaving in the key findings that propelled us toward integrating a cycle-accurate NeXTdimension into Previous.

#### Foundations: Initial ROM Analysis and Structural Exploration (Early 2023)

The journey commenced with the basics: acquiring and dissecting the NeXTdimension's 128KB boot ROM, a binary blob cryptically named `ND_step1_v43_eeprom.bin`. This firmware, preserved through community efforts at the Macintosh Repository, was the i860's starting point, distinct from the host NeXT's 68040 system ROM. Our first analyses, captured in files like `ROM_ANALYSIS.md` and `ND_ROM_STRUCTURE.md`, employed tools such as hexdump, binwalk, and entropy scans to map the ROM's layout. What emerged was a sparse structure: only about 10.9KB of actual code amid vast zero-filled regions, organized into nine distinct segments from boot vectors at 0x00000 to the reset block at 0x1FFE0. The ROM's position-independent design, with PC-relative addressing and heavy MMIO interactions at 0x02000000, hinted at a lightweight firmware focused on hardware initialization rather than a full OS.

Findings here were revelatory yet tentative. The boot sequence, traced via simple pattern matching, revealed a three-millisecond startup: reset vector at 0xFFF1FF20 branching to 0x00020 for PSR/EPSR setup, followed by FPU initialization and triple memory clears. Hardware detection routines probed DRAM (8-64MB) and VRAM (4MB), while a 28-iteration loop programmed the RAMDAC for the signature 1120x832@68Hz mode. But ambiguities abounded—why the heavy polling of the mailbox status register at 0x02000000? And what was this "GaCK" kernel it loaded into DRAM? These early documents also cross-referenced the host-side system ROM (Rev 2.5 v66), dissected in `ROMV66-0001E-02588.ASM`, to understand detection: the 68040 ROM scanned slot 2 config at 0x0200c800, expecting a 0x3600xxxx signature for 4Mbit DRAMs. This duality—host ROM initializing the board, i860 ROM bootstrapping locally—set the stage for emulating inter-processor handshakes in Previous.

Challenges surfaced immediately: the ROM's low code density suggested compression or overlays, and without an i860 disassembler, progress stalled. We pivoted to AI-assisted tools (noted in `CLAUDE.md`), using large language models to hypothesize code regions and correlate with historical NeXT docs. This phase yielded a provisional memory map: i860's local DRAM at 0x00000000, VRAM at 0x10000000, shared host window at 0x08000000, and MMIO at 0x02000000—crucial for mapping Previous's address spaces.

#### Phase 1: Static Disassembly and Pattern Recognition (Mid-2023)

Emboldened by the structure, we escalated to full disassembly using a custom MAME-based i860 tool, generating 32,802 lines in `ND_step1_v43_eeprom.asm`. `PHASE1_STATIC_ANALYSIS_RESULTS.md` and `DISASSEMBLY_ANALYSIS_FINDINGS.md` chronicled the output: entry points like 0x00020 (boot entry) and 0x01580 (main runtime loop), where the i860 polled the mailbox for host commands before DMA-loading the GaCK kernel to 0x00000000 and jumping there. Patterns emerged in assembly—memcpy/memset helpers at 0x02560, math primitives, and a command dispatcher routing to handlers for graphics ops. Entropy analysis confirmed nine code islands, with the largest (4KB at 0x01580) dedicated to kernel loading and mailbox polling.

Key discoveries included the firmware's "firmware download mechanism": upon detecting CMD_LOAD_KERNEL via mailbox, the i860 DMA-transfers the GaCK Mach kernel from shared memory, then relinquishes control permanently. This explained why the ROM never "returns"—it's a bootstrapper, not a persistent runtime. `I860_CODE_PATTERNS.md` and `I860_CODE_INVENTORY.md` inventoried recurring motifs: burst-mode DMA for VRAM transfers, VBL/HBL interrupt hooks, and PostScript-inspired opcodes like font caching and line drawing. Unexpectedly, section 7 revealed x86 code snippets (`SECTION7_X86_CODE_DISCOVERY.md` and `SECTION7_NEXTTV_APP_DISCOVERY.md`), likely for a NeXT TV decoder app— a hybrid architecture hinting at modular accelerators. This phase's playbook (`REVERSE_ENGINEERING_PLAYBOOK.md`) formalized our workflow: binwalk for sections, Ghidra/IDA for flows, and Python scripts for frequency analysis, ensuring reproducibility.

Yet, disassembly alone couldn't resolve dynamics. Call graphs were rudimentary (`CALLGRAPH_ANALYSIS.md`), showing branches to undefined handlers, and boot hangs in Previous tests (e.g., failing RAMDAC init) underscored the need for deeper verification.

#### Phases 2-3: Call Graphs, Protocols, and Kernel Deep Dive (Late 2023)

With structure in hand, we targeted the GaCK kernel's internals, treating the loaded DRAM image as an extension of the ROM. `ENTRY_POINT_ANALYSIS.md` and `FUNC_0xFFF07000_ANALYSIS.md` pinpointed the kernel's entry at 0xFFF07000, a boot loader invoking main at 0x01580. Building a complete call graph (`CALL_GRAPH_COMPLETE.md`) via recursive disassembly revealed a modular kernel: core at sections 1-2 (`SECTIONS12_MAIN_KERNEL_MAP.md`), init in section 4 (`SECTION4_DETAILED_MAP.md`), and utilities in 3/5/6 (`SECTION3_VERIFICATION_CARD.md`, etc.). `GaCK_KERNEL_RESEARCH.md` and `EMBEDDED_I860_KERNEL_ANALYSIS.md` dissected GaCK as a minimal Mach variant: no full filesystem, but real-time scheduling for DPS threads, dual-port shared memory with the 68040, and 10 interrupt sources (mailbox, DMA, VBL).

Protocol dissection was a breakthrough. `MAILBOX_PROTOCOL.md` and `HOST_I860_PROTOCOL_SPEC.md` reverse-engineered the 16-byte mailbox at 0x02000000: status, command (e.g., CMD_DPS_EXECUTE), data pointer, and args for host-i860 comms. `NDSERVER_ANALYSIS.md` and `ND_MACHDRIVER_ANALYSIS.md` analyzed the host-side Mach driver (`ND_MACHDRIVER_MEMORY_MAP.md`), confirming it serialized DPS scripts into mailbox buffers. Findings: 50+ commands classified (`COMMAND_CLASSIFICATION_CORRECTED.md`, `COMMAND_REFERENCE_CARDS.md`), from primitives like lineTo (0x01) to complex DPS ops. `DISPATCH_MECHANISM_ANALYSIS.md`, `DISPATCH_TABLE_SEARCH_RESULTS.md`, and `DISPATCH_AND_HANDLERS_ANALYSIS.md` mapped the kernel's jump table at 0x01600, routing to handlers like `dps_execute` for PostScript interpretation.

Graphics acceleration shone through in `GRAPHICS_PRIMITIVES_MAP.md` and `FONT_CACHE_ARCHITECTURE.md`: the i860 handled rasterization, bezier curves, and a 1MB font cache in VRAM, offloading the 68040. Boot sequence details (`ROM_BOOT_SEQUENCE_DETAILED.md`, `FIRMWARE_SPLASH_SCREEN_ANALYSIS.md`) clarified splash rendering via early primitives. Challenges included parameter conventions (`PARAMETER_CONVENTIONS.md`): i860's register-based ABI (r3-r31 for args) required careful emulation. `PHASE2_COMPLETE_SUMMARY.md` and `PHASE2_COMPLETION_PLAN.md` marked milestones—full dispatch mapping (`HANDLER_MAPPING_COMPLETE.md`)—enabling stub implementations in Previous's `dimension/` dir.

Incidents like the "Emacs changelog interference" (`THE_EMACS_CHANGELOG_INCIDENT.md`) highlighted real-world hurdles: accidental overwrites during annotation (`ANNOTATION_PROJECT_STATUS.md`), resolved via versioning.

#### Phase 4: Verification, Corrections, and Implementation Blueprints (Early 2024)

Verification became paramount as emulation prototypes emerged. Iterative cards (`SECTION4_VERIFICATION_CARD.md` through `SECTION11_VERIFICATION_CARD.md`, `SECTION_VALIDATION_REPORT.md`, `SECTIONS12_VERIFICATION_REPORT.md`) cross-checked disassembly against runtime dumps, confirming 95% code integrity. Memory maps culminated in `FINAL_VERIFIED_MEMORY_MAP.md` and `NEXTDIMENSION_MEMORY_MAP_COMPLETE.md`: host's 0xF8000000 window to i860's 0x08000000, with CSRs (0x020c0000) for DRAM config. Corrections refined our understanding—`POSTSCRIPT_OPERATORS_CORRECTED.md` and `OPERATOR_SIZE_VERIFICATION_REPORT.md` fixed operator counts (128 total, with buffer overflows in early stubs), while `CMD_DPS_EXECUTE_VERIFICATION_REPORT.md` validated the DPS handler's stack-based execution.

Implementation guides translated findings: `DPS_EXECUTE_IMPLEMENTATION.md` and `CMD_DPS_EXECUTE_FINAL_ANALYSIS.md` outlined Previous's i860 thread for PostScript parsing, syncing via `volatile int mainPauseEmulation`. `VIDEO_MODE_IMPLEMENTATION_GUIDE.md` detailed VRAM paging and genlock for NTSC/PAL I/O. The Gackling protocol—our coined term for mailbox serialization—evolved from design (`GACKLING_PROTOCOL_DESIGN.md`) to v1.1 (`GACKLING_PROTOCOL_DESIGN_V1.1.md`), with guides for interrupts (`GACKLING_INTERRUPT_IMPLEMENTATION_GUIDE.md`) and extraction (`GACKLING_EXTRACTION_GUIDE.md`). `GRAPHICS_ACCELERATION_GUIDE.md` and `KERNEL_ARCHITECTURE_COMPLETE.md` provided holistic blueprints: i860 at 33MHz in a SDL thread, DMA bursts for primitives, and FPU for curves.

Performance probes (`I860XP_RUST_PERFORMANCE_ANALYSIS.md`) tested Rust-based i860XP (with superscalar extensions) in Previous, revealing bottlenecks in decode (20% overhead) but 5x speedup for graphics vs. interpretive modes. `VRAM_UPGRADE_INVESTIGATION.md` explored 64MB extensions, while `FIRMWARE_PATCHING_ALTERNATIVE.md` proposed ROM mods for debugging, like injecting traces.

#### Culmination: Integration and Legacy (Mid-2024)

By `NEXTDIMENSION_RESEARCH_COMPLETE.md`, the puzzle was solved: a boot-to-DPS pipeline, from host detection (`ROM_ANALYSIS.md`'s Phase 1) to kernel runtime (`PHASE4_DEEP_ANALYSIS.md`), verified across sections (`SECTION6_VERIFICATION_CARD.md`). Sessions like `SESSION_SUMMARY_DISPATCH_ANALYSIS.md`, `SESSION_SUMMARY_NEXT_STEPS_COMPLETE.md`, and `SESSION_FINAL_SUMMARY.md` tied loose ends, with `MAIN_FUNCTION_COMPLETE.md`, `SECONDARY_FUNCTION_COMPLETE.md`, and `HELPER_FUNCTIONS_ANALYSIS.md` finalizing the call graph.

The process was iterative and humbling—early maps were 70% accurate, refined to 99% via verification; discoveries like x86 hybrids (`SECTION7_NEXTTV_APP_DISCOVERY.md`) expanded scope beyond graphics. For Previous, this yields a fully emulable NeXTdimension: boot ROM loads GaCK, host sends DPS via Gackling, i860 accelerates to VRAM, synced to the 68040 loop. Remaining gaps—full JPEG codec, audio DSP—point to future iterations, but the foundation revives a lost era of computing, preserving NeXT's visionary hardware for historians and hobbyists alike. This odyssey, spanning dozens of documents, exemplifies how patient reverse engineering resurrects the obsolete, one disassembled instruction at a time.
