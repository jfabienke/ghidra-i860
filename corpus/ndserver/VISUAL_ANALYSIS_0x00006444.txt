================================================================================
VISUAL ANALYSIS: FUN_00006444 (0x00006444)
Execution Flow Diagrams, Stack Visualization, and Timing Analysis
================================================================================

================================================================================
1. CONTROL FLOW DIAGRAM (Decision Tree)
================================================================================

                       Entry Point
                       (0x00006444)
                            |
                            v
                    [Setup Frame]
                   linkw A6, #0
                            |
                            v
                    [Save A2 (callee-save)]
                   movel A2, -(SP)
                            |
                            v
                    [Load Parameters]
                   A2 = error_context
                            |
                            v
                    [Prepare Library Call]
                   Push 3 arguments
                            |
                            v
                   [CALL Library Function]
                    bsr.l 0x050028ac
                            |
                            v
                   D0 = library result
                            |
                            v
                   [Check Result]
                  D1 = -1, compare
                            |
                            +---------+
                           / \        \
                          /   \        \
                      D0==-1? D0!=-1?
                      /          \
                     YES          NO
                    /              \
                   v                v
         [ERROR PATH]        [SUCCESS PATH]
              |                   |
              v                   v
      Read Hardware          Skip to
      0x040105b0             Cleanup
      Write to [A2]
              |
              +-------+
                      |
                      v
                  [Cleanup]
              Restore A2, unlink
                      |
                      v
                    [RTS]
                  Return to Caller

================================================================================
2. DATA FLOW DIAGRAM (Registers & Memory)
================================================================================

ENTRY POINT (0x00006444)
├─ FP: 0xXXXXXXXX (caller's A6)
├─ SP: 0xYYYYYYYY
├─ A2: Original value
├─ D0: Undefined
└─ D1: Undefined

                         ↓ linkw A6, #0

AFTER PROLOGUE (0x00006448)
├─ A6 = SP (new frame pointer)
├─ SP unchanged
└─ Stack: [Ret | Old-A6] ← A6/SP

                    ↓ movel A2, -(SP)

AFTER SAVE (0x0000644a)
├─ SP = SP - 4
├─ Stack: [Ret | Old-A6 | Old-A2] ← SP
└─ A2 preserved on stack

                ↓ moveal (0xc,A6), A2

AFTER PARAM LOAD (0x0000644e)
├─ A2 = [A6+12] (error context pointer)
├─ A2 now points to caller's buffer
└─ Will be used in error path

              ↓ Push 3 library arguments

BEFORE LIBRARY CALL (0x0000645a)
├─ SP = SP - 12 (three 32-bit args)
├─ Stack: [Ret | Old-A6 | Old-A2 | Arg3 | Arg4 | Arg5] ← SP
└─ Ready for bsr.l

                    ↓ bsr.l 0x050028ac

DURING LIBRARY CALL (0x050028ac)
├─ Library function executes
├─ Receives 3 arguments from stack
├─ May modify: D0, D1, A0, A1 (caller-save)
├─ Must preserve: A2, A6 (callee-save)
└─ Must not modify: SP (stack discipline)

                    ↓ Return to 0x00006460

AFTER LIBRARY CALL (0x00006460)
├─ D0 = library result
│  ├─ -1: Error
│  ├─ 0: Success (often close/close-like)
│  └─ >0: Success (other operations)
├─ A2 = preserved (unchanged)
├─ A6 = preserved (unchanged)
└─ Stack: [Ret | Old-A6 | Old-A2 | Arg3 | Arg4 | Arg5] ← SP

                ↓ moveq -1, D1; cmp.l D0, D1

AFTER ERROR CHECK (0x00006462)
├─ D1 = -1 (0xFFFFFFFF)
├─ CCR.Z = 1 if D0 == -1 (error)
├─ CCR.Z = 0 if D0 != -1 (success)
└─ D0, D1 unchanged (cmp doesn't store result)

                      ↓ bne.b 0x646c

BRANCH DECISION (0x00006464)
├─ If CCR.Z = 0 (success): Jump to 0x646c → SKIP ERROR PATH
└─ If CCR.Z = 1 (error): Fall through → EXECUTE ERROR PATH

SUCCESS PATH                         ERROR PATH
0x00006464                          0x00006466
│                                   │
├─ Branch → 0x646c                  └─ Read 0x040105b0
│                                      [A2] = hardware_state
└─ Return immediately
                                    Both paths converge:
                                    0x00006646c

CLEANUP (0x0000646c-0x00006472)
├─ moveal (-0x4,A6), A2  → Restore A2
├─ unlk A6               → Deallocate frame, restore A6, setup for rts
└─ rts                   → Return to caller

EXIT
├─ A2 = original value
├─ A6 = caller's A6
├─ SP = caller's SP
├─ D0 = library result (preserved)
└─ [A2] = may contain hardware state (if error occurred)

================================================================================
3. STACK FRAME VISUALIZATION
================================================================================

MEMORY LAYOUT AT KEY EXECUTION POINTS

Entry (immediately after bsr from caller):
┌─────────────────────────────────────┐
│  Caller's frame data                │  Higher addresses
├─────────────────────────────────────┤
│  Return address (0x00006da8)        │  ← [SP] initially
│  (pushed by bsr.l 0x6444)           │
├─────────────────────────────────────┤
│  Argument 1 (arg1)                  │  A6+8
├─────────────────────────────────────┤
│  Argument 2 (*error_context)        │  A6+12  ← A2 loaded here
├─────────────────────────────────────┤
│  Argument 3 (arg3 for library)      │  A6+16
├─────────────────────────────────────┤
│  Argument 4 (arg4 for library)      │  A6+20
├─────────────────────────────────────┤
│  Argument 5 (arg5 for library)      │  A6+24
├─────────────────────────────────────┤
  Lower addresses ↓

After linkw A6, #0:
┌─────────────────────────────────────┐
│  Arguments (as above)               │
├─────────────────────────────────────┤
│  Saved A6 (caller's frame)          │  ← [A6] = [SP] after linkw
├─────────────────────────────────────┤
  Lower addresses ↓

After movel A2, -(SP):
┌─────────────────────────────────────┐
│  Arguments (as above)               │
├─────────────────────────────────────┤
│  Saved A6                           │
├─────────────────────────────────────┤
│  Saved A2 (original value)          │  ← [SP] points here
├─────────────────────────────────────┤
  Lower addresses ↓

Before bsr.l to library (after pushing 3 args):
┌─────────────────────────────────────┐
│  Arguments (as above)               │
├─────────────────────────────────────┤
│  Saved A6                           │
├─────────────────────────────────────┤
│  Saved A2                           │
├─────────────────────────────────────┤
│  Arg 3 for library (0x10,A6)        │
├─────────────────────────────────────┤
│  Arg 4 for library (0x14,A6)        │
├─────────────────────────────────────┤
│  Arg 5 for library (0x18,A6)        │  ← [SP] points here
├─────────────────────────────────────┤
  Lower addresses ↓

Library Function's View (inside 0x050028ac):
┌─────────────────────────────────────┐
│  Return address (0x00006460)        │  ← [SP] in library
│  (pushed by bsr.l)                  │
├─────────────────────────────────────┤
│  Arg 1 to library (arg3)            │  [SP+4]
├─────────────────────────────────────┤
│  Arg 2 to library (arg4)            │  [SP+8]
├─────────────────────────────────────┤
│  Arg 3 to library (arg5)            │  [SP+12]
├─────────────────────────────────────┤
  (Library can see its arguments, our stack below)

After library returns (at 0x00006460):
┌─────────────────────────────────────┐
│  Arguments (as above)               │
├─────────────────────────────────────┤
│  Saved A6                           │
├─────────────────────────────────────┤
│  Saved A2                           │
├─────────────────────────────────────┤
│  Arg 3 for library                  │
├─────────────────────────────────────┤
│  Arg 4 for library                  │
├─────────────────────────────────────┤
│  Arg 5 for library                  │  ← [SP] points here (unchanged)
├─────────────────────────────────────┤
│  D0 = library result                │  (in register, not on stack)
├─────────────────────────────────────┤
  Lower addresses ↓

================================================================================
4. HARDWARE ACCESS VISUALIZATION
================================================================================

MEMORY MAP (m68k Address Space)

0x00000000 ┌─────────────────────────────────────────┐
           │         RAM (system memory)             │
           │  Executable code, data, stacks         │
           └─────────────────────────────────────────┘
           │
           │
0x04010000 │  I/O Space region
           │
           │  SYSTEM_PORT + 0x31C:
0x040105b0 │ ┌───────────────────────────────────┐   ← Hardware Register
           │ │    SYSTEM_DATA (32-bit)          │
           │ │  (read-only system status)       │
           │ └───────────────────────────────────┘
           │
           │
0xFFFFFFFF └─────────────────────────────────────────┘

READ OPERATION AT 0x00006466:

Initial State:
  A2 = 0x04001000 (pointer to error context buffer, for example)
  [0x04010000] = 0x0401xx00 (system status, example)
  [0x04001000] = 0x00000000 (uninitialized error buffer)

Instruction: move.l (0x040105b0).l, (A2)

Step 1: Read from hardware
  Read [0x040105b0] → temp = 0x0401xx00 (system state snapshot)

Step 2: Write to caller's buffer
  Write temp → [A2] = Write 0x0401xx00 → [0x04001000]

Final State:
  A2 = 0x04001000 (unchanged)
  [0x04010000] = 0x0401xx00 (unchanged, read-only)
  [0x04001000] = 0x0401xx00 (now contains system state)

Caller can then examine [0x04001000] to see system state at error time.

ERROR CONTEXT CAPTURE TIMING:

Timeline:
  t0: Library call made
  t1: Library executes
  t2: Library returns -1 (error)
  t3: Error path executes (IMMEDIATE)
      Hardware register read at THIS POINT
      Captures system state at error time (or very close)
  t4: Return to caller

Hardware state captured at t3 = immediately after library error
  → Very fresh snapshot
  → Reflects actual system condition at failure
  → Useful for diagnosing root cause

================================================================================
5. EXECUTION TIME DIAGRAM
================================================================================

Instruction                     Cycles (approx)
─────────────────────────────────────────────
0x6444: linkw A6, #0                   4
0x6448: movel A2, -(SP)                4
0x644a: moveal (0xc,A6), A2            8
0x644e: movel (0x18,A6), -(SP)         8
0x6452: movel (0x14,A6), -(SP)         8
0x6456: movel (0x10,A6), -(SP)         8
─────────────────────────────────────────────
                              Subtotal: 40 cycles

0x645a: bsr.l 0x050028ac              12 + Library execution
        (Library function ~50-200 cycles depending on operation)
─────────────────────────────────────────────
                              Subtotal: 50-212 cycles

0x6460: moveq #-1, D1                  2
0x6462: cmp.l D0, D1                   6
0x6464: bne.b 0x646c                   8 (if branch taken)
                                       6 (if fall-through)
─────────────────────────────────────────────
                              Subtotal: 14-16 cycles

SUCCESS PATH:
  Total: 40 + (50-212) + 14 = 104-266 cycles
  (branch taken, skip hardware read)

ERROR PATH:
  0x6466: move.l (0x040105b0).l,(A2)  20 (absolute addressing)
  Total: 40 + (50-212) + 6 + 20 = 116-278 cycles
  (fall through, execute hardware read)

0x646c: moveal (-0x4,A6), A2            8
0x6470: unlk A6                         6
0x6472: rts                             8
─────────────────────────────────────────────
                              Subtotal: 22 cycles

TOTAL EXECUTION (both paths): 138-300 cycles

Dominant factor: Library function execution time (0x050028ac)
Hardware read (20 cycles) is significant on error path

================================================================================
6. BRANCH PREDICTION (68040 specific)
================================================================================

Instruction: 0x6464 bne.b 0x646c (Branch if Not Equal)

Static Analysis (without runtime data):
  - Branch target: 0x646c (cleanup section)
  - Fall-through: 0x6466 (error recovery)

Prediction Strategy:
  - Success case (D0 != -1): Branch likely (skip error handling)
  - Error case (D0 == -1): Fall through (execute error handling)

68040 Pipeline Impact:
  - If branch taken (success): 8 cycles, skip 6 bytes (error handler)
  - If fall-through (error): 6 cycles, execute error handler

Pipeline Efficiency:
  Success path: Higher penalty (8 cycles for branch)
  Error path: Lower penalty (6 cycles, sequential execution)
  → Unusual: Error path slightly faster

Modern CPUs would benefit from branch prediction hints, but
68040 doesn't have such annotations.

================================================================================
7. CALLING SEQUENCE DIAGRAM
================================================================================

Caller (FUN_00006d24) at 0x00006da2:

            0x6da2: bsr.l 0x6444          ← Call FUN_00006444
                    │
                    ├─ Push return addr (0x6da8)
                    ├─ Jump to 0x6444
                    │
                    v
            FUN_00006444 (0x6444)
                    │
                    ├─ Setup & Execute (48 bytes)
                    ├─ Check library result
                    ├─ Conditionally read hardware
                    │
                    └─ rts (0x6472)
                       │
                       ├─ Pop return address
                       ├─ Jump to 0x6da8
                       │
                       v
            Caller resumed (0x6da8)
                    │
                    └─ Continue execution

Register State Across Boundary:

Before call:
  A6 = caller's frame pointer
  A2 = caller's A2
  SP = caller's stack

After call:
  A6 = caller's frame pointer (unchanged)
  A2 = caller's A2 (unchanged, restored by callee)
  SP = same as before call (cleanup handled by callee)
  D0 = library result (from FUN_00006444)

Caller can inspect:
  - D0: Library return value (-1 = error, else success)
  - *error_context: Hardware state (if error)

================================================================================
8. ERROR STATE FLOW DIAGRAM
================================================================================

Two Possible Outcomes:

PATH A: SUCCESS (Library call succeeds)

Caller (FUN_00006d24)
  │
  ├─ Setup arguments
  ├─ Call FUN_00006444
  │  │
  │  ├─ Call library function (0x050028ac)
  │  │  │
  │  │  └─ Returns D0 = value ≥ 0
  │  │
  │  ├─ Check: D0 == -1?  → NO
  │  │
  │  ├─ Branch to cleanup (skip hardware read)
  │  │
  │  └─ Return to caller
  │
  └─ D0 = ≥ 0 (success)
     *error_context = unchanged
     Caller knows operation succeeded


PATH B: ERROR (Library call fails)

Caller (FUN_00006d24)
  │
  ├─ Setup arguments
  ├─ Call FUN_00006444
  │  │
  │  ├─ Call library function (0x050028ac)
  │  │  │
  │  │  └─ Returns D0 = -1 (error)
  │  │
  │  ├─ Check: D0 == -1?  → YES
  │  │
  │  ├─ Fall through to hardware read
  │  │
  │  ├─ Read 0x040105b0 (system state)
  │  │
  │  ├─ Write to [A2] (error context buffer)
  │  │
  │  └─ Return to caller
  │
  ├─ D0 = -1 (error)
  ├─ *error_context = system state (diagnostic data)
  └─ Caller can examine both to diagnose failure

Diagnostic Info Available on Error:
  - D0 = -1 (confirmation of error)
  - [0x040105b0] = system state snapshot
  - Allows caller to:
    * Determine system condition
    * Decide on recovery action
    * Log error with context
    * Retry with different parameters

================================================================================
9. INSTRUCTION SEQUENCE & BYTE ADDRESSES
================================================================================

Address  Instr    Bytes  Opcode          Operands
─────────────────────────────────────────────────────────────────
0x6444   linkw    4      0x4e56 0000     A6, #0
0x6448   move.l   2      0x2c82          A2, -(SP)
0x644a   movea.l  4      0x2c6e 000c     (0xc,A6), A2
0x644e   move.l   4      0x2c6e 0018     (0x18,A6), -(SP)
0x6452   move.l   4      0x2c6e 0014     (0x14,A6), -(SP)
0x6456   move.l   4      0x2c6e 0010     (0x10,A6), -(SP)
0x645a   bsr.l    6      0x61ff XXXX     0x050028ac
0x6460   moveq    2      0x72ff          #-1, D1
0x6462   cmp.l    2      0xb381          D0, D1
0x6464   bne.b    2      0x6608          0x646c
0x6466   move.l   6      0x2b39 0401 05b0 (0x040105b0).l, (A2)
0x646c   movea.l  4      0x2c6e fffc     (-0x4,A6), A2
0x6470   unlk     2      0x4e5e          A6
0x6472   rts      2      0x4e75
─────────────────────────────────────────────────────────────────
Total size: 4+2+4+4+4+4+6+2+2+2+6+4+2+2 = 48 bytes ✓

Address Range: 0x6444 - 0x6473 (48 bytes = 0x30)

================================================================================
10. REGISTER ALIASING & CONSTRAINTS
================================================================================

Register Usage Summary:

┌─────────────────┬──────────────────────────────────────────────────┐
│ Register        │ Usage in FUN_00006444                            │
├─────────────────┼──────────────────────────────────────────────────┤
│ A6 (Frame ptr)  │ Saved by linkw, used for parameter access      │
│                 │ Restored by unlk                               │
├─────────────────┼──────────────────────────────────────────────────┤
│ A2              │ Saved at prologue (callee-save)                 │
│                 │ Loaded with error context pointer (A6+12)      │
│                 │ Used to write hardware state on error           │
│                 │ Restored at epilogue                           │
├─────────────────┼──────────────────────────────────────────────────┤
│ SP (A7)         │ Stack management (linkw/unlk)                   │
│                 │ Arguments pushed/popped                        │
│ (implicit)      │ Balanced throughout (no leaks)                  │
├─────────────────┼──────────────────────────────────────────────────┤
│ D0              │ Receives library function result                │
│                 │ Compared against -1                            │
│                 │ Preserved to exit (not modified after compare) │
│                 │ Available for caller inspection                │
├─────────────────┼──────────────────────────────────────────────────┤
│ D1              │ Loaded with error sentinel (-1)                 │
│                 │ Used in comparison (D0 vs D1)                  │
│                 │ Not preserved (scratch register)               │
├─────────────────┼──────────────────────────────────────────────────┤
│ A0, A1, D2-D7   │ Not used (may be modified by library call)      │
│ (scratch)       │ Not saved (caller's responsibility)            │
├─────────────────┼──────────────────────────────────────────────────┤
│ CCR             │ Modified by cmp.l instruction                  │
│ (Condition Code)│ Z flag critical for branch decision            │
│                 │ Not preserved (scratch)                        │
└─────────────────┴──────────────────────────────────────────────────┘

Callee-Save (Must Restore):
  A2, A3-A7, D2-D7

Caller-Save (Can Modify):
  D0, D1, A0, A1

FUN_00006444 Compliance:
  ✓ Saves A2 (callee-save)
  ✓ Restores A2 (callee-save)
  ✓ Doesn't modify other callee-save (doesn't use them)
  ✓ Can modify D0, D1 (caller-save)
  ✓ Library call may modify caller-save (ok)

Perfect compliance with m68k ABI.

================================================================================
11. HARDWARE STATE CAPTURE TIMING
================================================================================

Timeline of Error Path Execution:

T0: Library function called
    └─ bsr.l 0x050028ac
       └─ Jump to 0x050028ac
       └─ Library begins execution

T1: Library executes (50-200+ cycles)
    └─ Performs operation (read file, init device, etc.)
    └─ Encounters error condition
    └─ Returns -1 (error code)

T2: Return from library to 0x00006460
    └─ Instruction pointer = 0x00006460
    └─ D0 = -1 (error code)

T3: Error detection (0x00006460-0x00006464)
    └─ moveq #-1, D1  (load sentinel)
    └─ cmp.l D0, D1   (compare)
    └─ bne.b          (branch decision)
    └─ Z flag = 1 (equal, error confirmed)
    └─ Branch NOT taken (fall through)

T4: Hardware state capture (0x00006466)
    └─ move.l (0x040105b0).l, (A2)
    └─ READ from 0x040105b0 (system state AT THIS MOMENT)
    └─ WRITE to [A2] (caller's buffer)

T5: State captured
    └─ Hardware snapshot saved
    └─ Reflects system condition IMMEDIATELY after library error
    └─ Only ~26 cycles after library returned (-1)
    └─ Very fresh snapshot for diagnostics

T6: Return to caller (0x00006646c onwards)
    └─ Cleanup frame
    └─ Restore registers
    └─ rts
    └─ Back to FUN_00006d24

Caller Timeline Continuation (after return):
    └─ Examine D0 = -1 (error confirmation)
    └─ Examine [0x04001000] = captured state (diagnostic data)
    └─ Decide on recovery action
    └─ Log error if needed
    └─ Retry, abort, or continue

Value of Hardware Snapshot:
  - Captures EXACT system state at error time
  - No intervening instructions (immediate capture)
  - Allows offline analysis
  - Helps trace root cause
  - Enables intelligent error recovery

================================================================================
Generated: November 9, 2025
Analyzer: Claude Code (Haiku 4.5)
Binary: NDserver (NeXTdimension Mach-O m68k executable)
Function: FUN_00006444 @ 0x00006444 (48 bytes, 25668 decimal)
================================================================================
