# Ghidra export script - simplified to avoid encoding issues
# This exports functions and disassembly from NDserver

import json
import os

def main():
    print("=" + "=" * 78)
    print("Ghidra Export Script - NDserver Function Analysis")
    print("=" + "=" * 78)

    program = getCurrentProgram()
    if not program:
        print("ERROR: No program loaded")
        return

    # Create output directory
    project_dir = "/Users/jvindahl/Development/nextdimension/ndserver_re"
    output_dir = os.path.join(project_dir, "ghidra_export")

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        print("Created output directory: " + output_dir)

    # Export functions
    print("\n[1] Exporting function list...")
    functions = export_function_list(program, output_dir)

    # Export call graph
    print("\n[2] Exporting call graph...")
    calls = export_call_graph(program, output_dir)

    # Export disassembly
    print("\n[3] Exporting disassembly...")
    export_disassembly(program, output_dir)

    print("\n" + "=" * 80)
    print("Export complete!")
    print("  Functions: " + str(len(functions)))
    print("  Call relationships: " + str(len(calls)))
    print("  Output: " + output_dir)
    print("=" * 80)

def export_function_list(program, output_dir):
    """Export all functions to JSON"""
    function_manager = program.getFunctionManager()
    functions = []

    for func in function_manager.getFunctions(True):
        addr = func.getEntryPoint()
        body = func.getBody()

        func_data = {
            'address': int(addr.getOffset()),
            'address_hex': "0x{:08x}".format(addr.getOffset()),
            'name': func.getName(),
            'size': body.getNumAddresses() if body else 0,
            'thunk': func.isThunk(),
            'external': func.isExternal()
        }
        functions.append(func_data)

    output_file = os.path.join(output_dir, "functions.json")
    with open(output_file, 'w') as f:
        json.dump(functions, f, indent=2)

    print("  Exported {} functions to: {}".format(len(functions), output_file))
    return functions

def export_call_graph(program, output_dir):
    """Export call graph"""
    function_manager = program.getFunctionManager()
    call_graph = []

    for func in function_manager.getFunctions(True):
        # Skip external/thunk functions
        if func.isExternal() or func.isThunk():
            continue

        func_addr = func.getEntryPoint()
        called_functions = []

        # Get all functions this one calls
        for called in func.getCalledFunctions(None):
            called_functions.append({
                'address': int(called.getEntryPoint().getOffset()),
                'address_hex': "0x{:08x}".format(called.getEntryPoint().getOffset()),
                'name': called.getName()
            })

        if called_functions:
            call_graph.append({
                'function': {
                    'address': int(func_addr.getOffset()),
                    'address_hex': "0x{:08x}".format(func_addr.getOffset()),
                    'name': func.getName()
                },
                'calls': called_functions
            })

    output_file = os.path.join(output_dir, "call_graph.json")
    with open(output_file, 'w') as f:
        json.dump(call_graph, f, indent=2)

    print("  Exported {} call relationships to: {}".format(len(call_graph), output_file))
    return call_graph

def export_disassembly(program, output_dir):
    """Export complete disassembly"""
    listing = program.getListing()
    function_manager = program.getFunctionManager()

    # Only disassemble m68k code region
    addr_factory = program.getAddressFactory().getDefaultAddressSpace()
    start_addr = addr_factory.getAddress(0x00002d10)
    end_addr = addr_factory.getAddress(0x000075f8)

    output_file = os.path.join(output_dir, "disassembly_full.asm")

    with open(output_file, 'w') as f:
        f.write("; NDserver Complete Disassembly\n")
        f.write("; Generated by Ghidra\n")
        f.write("; m68k code region: 0x00002d10 - 0x000075f8\n")
        f.write(";\n\n")

        current_addr = start_addr
        instruction_count = 0
        current_function = None

        while current_addr is not None and current_addr.compareTo(end_addr) <= 0:
            # Check for function boundary
            func = function_manager.getFunctionAt(current_addr)
            if func and func != current_function:
                current_function = func
                f.write("\n")
                f.write("; " + "=" * 76 + "\n")
                f.write("; Function: {}\n".format(func.getName()))
                f.write("; Address: 0x{:08x}\n".format(current_addr.getOffset()))
                if func.getBody():
                    f.write("; Size: {} bytes\n".format(func.getBody().getNumAddresses()))
                f.write("; " + "=" * 76 + "\n\n")

            # Get instruction
            instruction = listing.getInstructionAt(current_addr)
            if instruction:
                # Format instruction
                mnemonic = instruction.getMnemonicString()

                # Get all operands
                operands = []
                for i in range(instruction.getNumOperands()):
                    operands.append(instruction.getDefaultOperandRepresentation(i))
                operand_str = ",".join(operands) if operands else ""

                # Check for call references
                comment = ""
                refs = instruction.getReferencesFrom()
                for ref in refs:
                    if ref.getReferenceType().isCall():
                        target_func = function_manager.getFunctionAt(ref.getToAddress())
                        if target_func:
                            comment = " ; -> {}".format(target_func.getName())
                            break

                f.write("  0x{:08x}:  {:<10} {:<30}{}\n".format(
                    current_addr.getOffset(),
                    mnemonic,
                    operand_str,
                    comment
                ))

                instruction_count += 1
                current_addr = instruction.getMaxAddress().add(1)
            else:
                # No instruction, skip
                current_addr = current_addr.add(1)

        f.write("\n; Total instructions: {}\n".format(instruction_count))

    print("  Exported {} instructions to: {}".format(instruction_count, output_file))

if __name__ == '__main__':
    main()
