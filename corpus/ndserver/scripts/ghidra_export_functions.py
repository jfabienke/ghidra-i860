# Ghidra Python script to export function information
# encoding: utf-8
# This script exports:
# 1. All discovered functions with addresses
# 2. All BSR/JSR calls with resolved targets
# 3. Complete disassembly with symbols

import json
import os

def main():
    print("=" * 80)
    print("Ghidra Function Export Script")
    print("=" * 80)

    program = getCurrentProgram()
    if program is None:
        print("ERROR: No program loaded")
        return

    # Export paths
    script_dir = os.path.dirname(os.path.abspath(getScriptArgs()[0])) if getScriptArgs() else "/Users/jvindahl/Development/nextdimension/ndserver_re/scripts"
    project_dir = os.path.dirname(script_dir)
    output_dir = os.path.join(project_dir, "ghidra_export")

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Export 1: Function list with symbols
    export_functions(program, os.path.join(output_dir, "functions.json"))

    # Export 2: Call graph (BSR/JSR targets)
    export_call_graph(program, os.path.join(output_dir, "call_graph.json"))

    # Export 3: Disassembly with symbols
    export_disassembly(program, os.path.join(output_dir, "disassembly.asm"))

    print("\n" + "=" * 80)
    print("Export completed successfully")
    print("Output directory: " + output_dir)
    print("=" * 80)

def export_functions(program, output_path):
    """Export all functions to JSON"""
    print("\n[1] Exporting functions...")

    function_manager = program.getFunctionManager()
    functions = []

    for func in function_manager.getFunctions(True):  # True = forward iteration
        func_entry = func.getEntryPoint()
        func_body = func.getBody()

        func_data = {
            'address': "0x{:08x}".format(func_entry.getOffset()),
            'name': func.getName(),
            'size': func_body.getNumAddresses() if func_body else 0,
            'thunk': func.isThunk(),
            'external': func.isExternal(),
        }
        functions.append(func_data)

    with open(output_path, 'w') as f:
        json.dump(functions, f, indent=2)

    print("  Exported {} functions to: {}".format(len(functions), output_path))

def export_call_graph(program, output_path):
    """Export call graph - who calls whom"""
    print("\n[2] Exporting call graph...")

    function_manager = program.getFunctionManager()
    listing = program.getListing()
    call_graph = []

    for func in function_manager.getFunctions(True):
        func_entry = func.getEntryPoint()
        func_name = func.getName()

        # Get all calls made by this function
        called_functions = []
        for called_func in func.getCalledFunctions(None):  # None = use default monitor
            called_functions.append({
                'address': "0x{:08x}".format(called_func.getEntryPoint().getOffset()),
                'name': called_func.getName()
            })

        if called_functions:
            call_graph.append({
                'function': {
                    'address': "0x{:08x}".format(func_entry.getOffset()),
                    'name': func_name
                },
                'calls': called_functions
            })

    with open(output_path, 'w') as f:
        json.dump(call_graph, f, indent=2)

    print("  Exported {} call relationships to: {}".format(len(call_graph), output_path))

def export_disassembly(program, output_path):
    """Export complete disassembly with symbols"""
    print("\n[3] Exporting disassembly...")

    listing = program.getListing()
    function_manager = program.getFunctionManager()

    # Only disassemble m68k code region
    addr_factory = program.getAddressFactory().getDefaultAddressSpace()
    start_addr = addr_factory.getAddress(0x00002d10)
    end_addr = addr_factory.getAddress(0x000075f8)

    with open(output_path, 'w') as f:
        f.write("; NDserver Disassembly\n")
        f.write("; Generated by Ghidra\n")
        f.write("; m68k code region: 0x00002d10 - 0x000075f8\n")
        f.write(";\n\n")

        current_addr = start_addr
        instruction_count = 0

        while current_addr <= end_addr:
            # Check if this is a function entry point
            func = function_manager.getFunctionAt(current_addr)
            if func:
                f.write("\n")
                f.write("; " + "=" * 76 + "\n")
                f.write("; Function: {}\n".format(func.getName()))
                f.write("; Address: 0x{:08x}\n".format(current_addr.getOffset()))
                if func.getBody():
                    f.write("; Size: {} bytes\n".format(func.getBody().getNumAddresses()))
                f.write("; " + "=" * 76 + "\n")
                f.write("\n")
                f.write("{}:\n".format(func.getName()))

            # Get instruction at this address
            instruction = listing.getInstructionAt(current_addr)
            if instruction:
                # Format: address: mnemonic operands  ; comment
                mnemonic = instruction.getMnemonicString()
                operands = instruction.getDefaultOperandRepresentation(0) if instruction.getNumOperands() > 0 else ""

                # Build operand string for all operands
                operand_strs = []
                for i in range(instruction.getNumOperands()):
                    operand_strs.append(instruction.getDefaultOperandRepresentation(i))
                operands = ",".join(operand_strs) if operand_strs else ""

                # Check for references (calls, data refs)
                comment = ""
                refs = instruction.getReferencesFrom()
                for ref in refs:
                    if ref.getReferenceType().isCall():
                        target_func = function_manager.getFunctionAt(ref.getToAddress())
                        if target_func:
                            comment = " ; call {}".format(target_func.getName())
                            break

                f.write("  0x{:08x}:  {:<8} {:<30}{}\n".format(
                    current_addr.getOffset(),
                    mnemonic,
                    operands,
                    comment
                ))

                instruction_count += 1
                current_addr = instruction.getMaxAddress().add(1)
            else:
                # No instruction, skip to next address
                current_addr = current_addr.add(1)

        f.write("\n; End of disassembly\n")
        f.write("; Total instructions: {}\n".format(instruction_count))

    print("  Exported {} instructions to: {}".format(instruction_count, output_path))

if __name__ == '__main__':
    main()
