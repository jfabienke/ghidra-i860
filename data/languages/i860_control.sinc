# ======================================================================
# Intel i860 Control Flow Instructions
# Branches, calls, traps, indirect jumps
# ======================================================================

# ==================================================================
# Unconditional Branch and Call (26-bit PC-relative, WITH delay slot)
# MAME confirms: br, call both have delay slots
# ==================================================================

# br target — unconditional branch, WITH delay slot
:br br26target  is op6=0x1A & br26target  {
    delayslot(1);
    goto br26target;
}

# call target — saves PC+4 to r1, WITH delay slot
:call br26target  is op6=0x1B & br26target  {
    r1 = inst_next;
    delayslot(1);
    call br26target;
}

# ==================================================================
# Conditional Branches (26-bit PC-relative)
# ==================================================================

# bc target — branch if CC set, NO delay slot
:bc br26target  is op6=0x1C & br26target  {
    if (CC != 0) goto br26target;
}

# bc.t target — branch if CC set, WITH delay slot
# Manual states bc.t (not taken) annuls (skips) the delay slot.
# If CC is 0 (not taken), we jump to the instruction after the delay slot.
:bc.t br26target  is op6=0x1D & br26target  {
    if (CC == 0) goto [inst_next + 4];
    delayslot(1);
    goto br26target;
}

# bnc target — branch if CC clear, NO delay slot
:bnc br26target  is op6=0x1E & br26target  {
    if (CC == 0) goto br26target;
}

# bnc.t target — branch if CC clear, WITH delay slot
# Manual states bnc.t (not taken) annuls (skips) the delay slot.
# If CC is not 0 (not taken), we jump to the instruction after the delay slot.
:bnc.t br26target  is op6=0x1F & br26target  {
    if (CC != 0) goto [inst_next + 4];
    delayslot(1);
    goto br26target;
}

# ==================================================================
# Compare-and-Branch (split offset, register or immediate)
# ==================================================================

# bte src1,src2,sbroff — branch if equal, NO delay slot (register form)
:bte R1src, src2, sbroff  is op6=0x16 & R1src & src2 & sbroff  {
    if (R1src == src2) goto sbroff;
}

# bte #imm5,src2,sbroff — branch if equal, NO delay slot (immediate form)
:bte imm5, src2, sbroff  is op6=0x17 & imm5 & src2 & sbroff  {
    if (src2 == imm5) goto sbroff;
}

# btne src1,src2,sbroff — branch if not equal, NO delay slot (register form)
:btne R1src, src2, sbroff  is op6=0x14 & R1src & src2 & sbroff  {
    if (R1src != src2) goto sbroff;
}

# btne #imm5,src2,sbroff — branch if not equal, NO delay slot (immediate form)
:btne imm5, src2, sbroff  is op6=0x15 & imm5 & src2 & sbroff  {
    if (src2 != imm5) goto sbroff;
}

# ==================================================================
# Branch on LCC and Add (bla) — WITH delay slot
# bla src1,src2,sbroff
# 1. Save current LCC (CC)
# 2. Compute new LCC: carry check
# 3. src2 = src1 + src2
# 4. Execute delay slot
# 5. If old LCC was set, branch to target
# ==================================================================
:bla R1src, src2, sbroff  is op6=0x2D & R1src & src2 & sbroff  {
    local oldCC:1 = (CC != 0);
    CC = zext(carry(src2, R1src));
    src2 = src2 + R1src;
    delayslot(1);
    if (oldCC) goto sbroff;
}

# ==================================================================
# Indirect Branch/Call — ALL have delay slots per MAME reference
# ==================================================================

# ret — bri r1 recognized as function return (most specific match)
# Only constrain src1=1 (r1). The src2/dest fields are unused in bri encoding;
# real binaries often have non-zero values in these fields.
:ret  is op6=0x10 & src1_zero=1  {
    delayslot(1);
    return [r1];
}

# bri src1 — indirect branch, WITH delay slot
# Catches bri with src1 != r1. When src1=r1, the more-specific ret matches.
:bri R1src  is op6=0x10 & R1src  {
    delayslot(1);
    goto [R1src];
}

# calli src1 — call indirect (core escape 0x13, sub-opcode 0x02)
# In XP mode, escop=0x02 with dest!=0 is ldint (see i860_xp.sinc), which is
# more specific and wins. No constraints on unused src2/dest fields — real
# binaries often have non-zero values.
:calli R1src  is op6=0x13 & escop=0x02 & R1src  {
    r1 = inst_next;
    delayslot(1);
    call [R1src];
}

# ==================================================================
# Trap
# ==================================================================

# trap src1,src2,dest — software trap
:trap R1src, R2src, Rdest  is op6=0x11 & R1src & R2src & Rdest  {
    i860_trap(R1src, R2src);
}

# ==================================================================
# Core Escape Operations (primary opcode 0x13)
# ==================================================================

# intovr — integer overflow trap (sub-opcode 0x04)
:intovr  is op6=0x13 & escop=0x04  {
    i860_intovr();
}

# lock — bus lock (sub-opcode 0x01)
:lock  is op6=0x13 & escop=0x01  {
    i860_lock();
}

# unlock — bus unlock (sub-opcode 0x07)
:unlock  is op6=0x13 & escop=0x07  {
    i860_unlock();
}
